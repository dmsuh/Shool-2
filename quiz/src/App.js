import { useState } from 'react';
import './index.scss';

// массив вопросов
const questions = [
  {
    id: 1001,
    title: 'React - это ... ?',
    variants: ['библиотека', 'фреймворк', 'приложение'],
    correct: 0,
  },
  {
    id: 1002,
    title: 'Компонент - это ... ',
    variants: ['приложение', 'часть приложения или страницы', 'то, что я не знаю что такое'],
    correct: 1,
  },
  {
    id: 1003,
    title: 'Что такое JSX?',
    variants: [
      'Это простой HTML',
      'Это функция',
      'Это тот же HTML, но с возможностью выполнять JS-код',
    ],
    correct: 2,
  },
  {
    id: 1004,
    title: 'Зачем нужен хук "useState" ?',
    variants: [
      'Для определения состояния и его обновления',
      'Определяет статистику переданного объекта',
      'Функция Java Script выполняющая асинхронный запрос',
    ],
    correct: 0,
  },
  {
    id: 1005,
    title: 'Какой подход мы используем, при создании приложений в ReactJS?',
    variants: [
      'Single page application',
      'Multi page application',
      'Mega page application',
    ],
    correct: 0,
  },
  {
    id: 1006,
    title: 'Что такое Хуки в ReactJS?',
    variants: [
      'Механизм в React, который позволяет работать полностью без классов',
      'Механизм в React, который позволяет создавать классы объектов для их изменения',
      'Механизм в React, который позволяет работать с путями перемещения по сайту',
    ],
    correct: 0,
  },
  {
    id: 1007,
    title: 'Компонентный подход это - ... ?',
    variants: [
      'Способ организации приложения в виде одного компонента',
      'Способ организации методов классового программирования',
      'Способ организации приложения в виде иерархии компонентов',
    ],
    correct: 2,
  },
  {
    id: 1008,
    title: 'Виртуальный DOM это - ... ?',
    variants: [
      'Это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM',
      'Наше представление DOM и его древовидной структуры',
      'Это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса не хранится в памяти и работает напрямую с пользователем при помощи библиотеки, такой как ReactDOM',
    ],
    correct: 0,
  },
  {
    id: 1009,
    title: 'В чем отличия VirtualDOM от DOM?',
    variants: [
      'В отличие от DOM, Virtual DOM не является официальной спецификацией, а представляет собой новый метод взаимодействия с DOM, позволяющий обновлять только изменившиеся узлы DOM-дерева, а не перерисовывать всю страницу',
      'В отличие от DOM, Virtual DOM является официальной спецификацией, а представляет собой новый метод взаимодействия с DOM, позволяющий обновлять всю страницу без точечного воздействия на каждый узел DOM-дерева',
      'Надпись "Virtual"',
    ],
    correct: 0,
  },
];

// функция результата, передаем в нее функцию обновления страницы 
// и счетчик правильных ответов
function Result({ correct, reLoadPage }) {
  return (
    <div className="result">
      <img src="https://cdn-icons-png.flaticon.com/512/2278/2278992.png" alt='icon' />
      <h2>Вы ответили верно на {correct} из {questions.length} </h2>

      {/* передаем true что бы обновить из сервера, а не из хеша */}
      <button onClick={() => reLoadPage(true)}>Попробовать снова</button>
    </div>
  );
}

// функция самого опросника, передаем в "step"-числовое значение связанное 
// с индексом вопроса в массиве вопросов, переменную для связи "step" и массива 
// и третьим - функцию для отслеживания нажатия на ответ
function Game({ step, question, onClickVariant }) {
  // переменная отслуживающая процент текущего прохождения вопросов, пример - "24"
  let reSizeBar = Math.round(step / questions.length * 100)

  return (
    <>
      <div className="progress">
        <div style={{ width: `${reSizeBar}%` }} className="progress__inner"></div>
      </div>
      <h1>{question.title}</h1>

      {/* используем метод map для прохождения по массиву вопросов и преображаем их в ячейки списка "li" */}
      <ul>
        {
          question.variants.map((item, index) => (
            <li onClick={() => onClickVariant(index)} key={item}> {item} </li>
          ))
        }
      </ul>
    </>
  );
}

function App() {
  // создаем состояние нашего числа для отслеживания индекса вопроса, 
  // в будущем увеличивая его мы будем переходить на другой вопрос 
  // по индексу вопроса в массиве
  const [step, setStep] = useState(0);

  // состояние переменной отвечающей за количество верных вопросов
  const [correct, setCorrect] = useState(0);

  // получаем текущий вопрос по индексу из хука useState "step"
  const question = questions[step]
  
  // стрелочная функция принимает в себя индекс нажатого нами вопроса, 
  // для использования в function Game > ul > map
  const onClickVariant = (index) => {
    // увеличиваем (индекс вопроса в массиве) step на 1 для смены вопроса
    setStep(step + 1);

    // если index вопроса на который мы нажали ровняется правильному ответу
    // увеличиваем "correct" отвечающую за количество верных ответов на 1
    if (index === question.correct) {
      setCorrect(correct + 1)
    }
  };


  // функция запускающая обновления страницы, при передачи тру 
  // грузит данные с сервера, а не с хеша
  // использование в function Result > button > onClick
  const reLoadPage = () => {
    window.location.reload(true)
  }

  return (
    <div className="App">
      {/* если вопросы кончались отображаем результат  */}
      {
        step !== questions.length ? (
          <Game step={step} question={question} onClickVariant={onClickVariant} />
        ) : (
          <Result correct={correct} reLoadPage={reLoadPage} />
        )
      }
    </div>
  );
}

export default App;
